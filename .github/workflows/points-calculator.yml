name: Points Calculator

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Triggers on PR close (merged or abandoned). The job condition below filters
# to merged-only. pull_request_target is used for the same reason as the
# validator: so GITHUB_TOKEN retains write access even for fork PRs.
#
# IMPORTANT: contents: write is required here because this job commits the
# updated leaderboard JSON file back to the repository.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
on:
  pull_request_target:
    types: [closed]

permissions:
  pull-requests: write
  issues: write
  contents: write   # needed to read/write leaderboard.json in the repo

jobs:
  calculate-points:
    # Only run when the PR was actually merged, not just closed/abandoned
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      # â”€â”€ Step 1: Check out the base branch so we can read/write leaderboard.json
      # We check out the BASE repo only (not the PR's head) â€” this is safe with
      # pull_request_target and avoids executing untrusted code from forks.
      - name: Checkout base repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          # PAT_TOKEN needed â€” org strips write access from GITHUB_TOKEN on forks.
          token: ${{ secrets.PAT_TOKEN }}

      # â”€â”€ Step 2: Calculate points and update leaderboard.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Calculate and Award Points
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const fs       = require('fs');
            const pr       = context.payload.pull_request;
            const body     = pr.body || '';
            const prNumber = pr.number;
            const prUrl    = pr.html_url;
            const author   = pr.user.login;
            const footer   = '\n\n> GDG CHARUSAT Open Source Contri Sprintathon';

            const postComment = async (text) => {
              await github.rest.issues.createComment({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: prNumber,
                body:         text
              });
            };

            // â”€â”€ 1. Extract team number â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const teamMatch = body.match(/team\s*(\d+)/i);
            if (!teamMatch) {
              await postComment(
                `## âš ï¸ Points Not Awarded\n\n` +
                `This PR was merged but no team number was found in the description.\n\n` +
                `Please contact the organizers to have your points manually added:\n` +
                `- WhatsApp: +91-8347036131\n` +
                `- Email: jadejakrishnapal04@gmail.com` +
                footer
              );
              return;
            }

            const teamNumber = teamMatch[1].padStart(2, '0');
            const teamLabel  = `Team ${teamNumber}`;

            // â”€â”€ 2. Determine points â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Helper: scan an array of label name strings for a level label.
            const levelFromLabels = (labelNames) => {
              const lower = labelNames.map(n => n.toLowerCase());
              if (lower.includes('level-2') || lower.includes('intermediate')) return { points: 20, level: 'Level 2 â€” Intermediate' };
              if (lower.includes('level-1') || lower.includes('beginner') || lower.includes('good-first-issue')) return { points: 5, level: 'Level 1 â€” Beginner' };
              return null;
            };

            const issueMatch     = body.match(/(close[sd]?|fix(e[sd])?|resolve[sd]?)\s*#(\d+)/i);
            const hasLinkedIssue = Boolean(issueMatch);

            let points      = 0;
            let level       = '';
            let pointSource = '';

            if (hasLinkedIssue) {
              // â”€â”€ TYPE 1: Read level from the linked ISSUE's labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              const issueNumber = parseInt(issueMatch[3]);
              pointSource = `Linked Issue #${issueNumber}`;

              try {
                const issueData  = await github.rest.issues.get({
                  owner:        context.repo.owner,
                  repo:         context.repo.repo,
                  issue_number: issueNumber
                });
                const issueLabels = issueData.data.labels.map(l => l.name);
                const result      = levelFromLabels(issueLabels);

                if (result) {
                  points = result.points;
                  level  = result.level;
                } else {
                  // Issue exists but has no level label â€” fall back to PR labels
                  const prResult = levelFromLabels(pr.labels.map(l => l.name));
                  if (prResult) {
                    points = prResult.points;
                    level  = prResult.level + ' (from PR label)';
                  } else {
                    // Neither issue nor PR has a level label â€” award minimum & alert admin
                    points = 5;
                    level  = 'Level 1 â€” Beginner (fallback: no level label on issue or PR)';
                  }
                }
              } catch (_) {
                // Issue not found (deleted, different repo, etc.) â€” safe fallback
                points = 5;
                level  = 'Level 1 â€” Beginner (fallback: issue not found)';
              }

            } else {
              // â”€â”€ TYPE 2: Read level from the PR's OWN labels (admin-assigned) â”€
              pointSource     = 'General Improvement PR â€” level assigned by admin';
              const prResult  = levelFromLabels(pr.labels.map(l => l.name));

              if (!prResult) {
                // Admin forgot to add a level label before merging
                await postComment(
                  `## âš ï¸ Points Could Not Be Calculated\n\n` +
                  `This General Improvement PR was merged without a \`level-1\` or \`level-2\` label.\n\n` +
                  `**Admin action required:** manually add points for **${teamLabel}** in the leaderboard.\n\n` +
                  `| Label | Points |\n` +
                  `|---|---|\n` +
                  `| \`level-1\` | 5 pts |\n` +
                  `| \`level-2\` | 20 pts |` +
                  footer
                );
                return;
              }

              points = prResult.points;
              level  = prResult.level + ' (admin assigned)';
            }

            // â”€â”€ 3. Post award comment on the PR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            await postComment(
              `## ğŸ‰ PR Merged â€” Points Awarded!\n\n` +
              `Congratulations @${author}! Your contribution has been merged.\n\n` +
              `| Field | Value |\n` +
              `|---|---|\n` +
              `| **Team** | ${teamLabel} |\n` +
              `| **Level** | ${level} |\n` +
              `| **Points Awarded** | ${points} pts |\n` +
              `| **Source** | ${pointSource} |\n\n` +
              `The leaderboard has been updated. Keep contributing!` +
              footer
            );

            // â”€â”€ 4. Update leaderboard.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // We store scores in a JSON file in the repo so the data is durable
            // and doesn't depend on parsing Markdown tables (which is fragile).
            const LB_PATH = 'leaderboard.json';
            let scores    = {};

            if (fs.existsSync(LB_PATH)) {
              try { scores = JSON.parse(fs.readFileSync(LB_PATH, 'utf8')); } catch (_) {}
            }

            if (!scores[teamLabel]) scores[teamLabel] = { points: 0, prs: 0, contributors: [] };
            scores[teamLabel].points += points;
            scores[teamLabel].prs    += 1;
            if (!scores[teamLabel].contributors.includes(author)) {
              scores[teamLabel].contributors.push(author);
            }

            fs.writeFileSync(LB_PATH, JSON.stringify(scores, null, 2));

            // â”€â”€ 5. Regenerate leaderboard.md for human-readable display â”€â”€â”€â”€
            const sorted = Object.entries(scores).sort((a, b) => b[1].points - a[1].points);
            const medals  = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
            const rows    = sorted.map(([team, data], i) => {
              const rank = i < 3 ? medals[i] : `${i + 1}.`;
              return `| ${rank} | ${team} | ${data.points} | ${data.prs} | ${data.contributors.join(', ')} |`;
            }).join('\n');

            const now    = new Date().toUTCString();
            const mdBody =
              `# GDG CHARUSAT Open Source Contri Sprintathon â€” Leaderboard\n\n` +
              `> **Last Updated:** ${now}\n\n` +
              `---\n\n` +
              `## ğŸ† Scores\n\n` +
              `| Rank | Team | Points | PRs Merged | Contributors |\n` +
              `|------|------|--------|------------|-------------|\n` +
              (rows || `| â€” | No contributions yet | 0 | 0 | â€” |`) +
              `\n\n---\n\n` +
              `## Points System\n\n` +
              `| Level | Label | Points |\n` +
              `|-------|-------|--------|\n` +
              `| Beginner | \`level-1\` / \`good-first-issue\` | 5 pts |\n` +
              `| Intermediate | \`level-2\` / \`intermediate\` | 20 pts |\n` +
              `| General Improvement | Admin assigns level on PR | 5 or 20 pts |\n\n` +
              `---\n\n` +
              `*Auto-updated on every merged PR Â· Maintained by GDG CHARUSAT*\n`;

            fs.writeFileSync('leaderboard.md', mdBody);
            core.info(`Leaderboard updated for ${teamLabel}: +${points} pts`);

      # â”€â”€ Step 3: Commit leaderboard.json + leaderboard.md back to the repo â”€
      - name: Commit leaderboard update
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add leaderboard.json leaderboard.md
          # Only commit if something actually changed (idempotent)
          git diff --staged --quiet || git commit -m "chore: update leaderboard [skip ci]"
          git push
